											26/02/2025
***************************************Escopo do projeto Minishell*************************************

/minishell
â”œâ”€â”€ Makefile              // Regras para compilar o projeto, incluindo all, clean, fclean, re e bonus (se houver)
â”œâ”€â”€ minishell.h           // CabeÃ§alho principal com includes, defines e declaraÃ§Ãµes de estruturas e funÃ§Ãµes globais
â”œâ”€â”€ main.c                // FunÃ§Ã£o principal: inicializa, entra no loop de leitura (prompt), chama parser e executor
â”œâ”€â”€ parser
â”‚   â”œâ”€â”€ parser.c          // FunÃ§Ãµes de tokenizaÃ§Ã£o, tratamento de aspas, redirecionamentos e construÃ§Ã£o da estrutura de comandos
â”‚   â”œâ”€â”€ parser.h          // ProtÃ³tipos e estruturas relacionadas ao parser
â”‚   â””â”€â”€ parser_bonus.c    // FunÃ§Ãµes extras para tratar operadores lÃ³gicos (&&, ||) e agrupamento com parÃªnteses (bonus)
â”œâ”€â”€ executor
â”‚   â”œâ”€â”€ executor.c        // ExecuÃ§Ã£o dos comandos, criaÃ§Ã£o de processos, gerenciamento de pipes e redirecionamentos
â”‚   â”œâ”€â”€ executor.h        // ProtÃ³tipos e estruturas para execuÃ§Ã£o
â”‚   â””â”€â”€ executor_bonus.c  // Tratamento de condiÃ§Ãµes extras e expansÃ£o de wildcards (bonus)
â”œâ”€â”€ builtins
â”‚   â”œâ”€â”€ builtins.c        // ImplementaÃ§Ã£o dos builtins: echo, cd, pwd, export, unset, env e exit
â”‚   â””â”€â”€ builtins.h        // ProtÃ³tipos e definiÃ§Ãµes dos builtins
â”œâ”€â”€ utils
â”‚   â”œâ”€â”€ utils.c           // FunÃ§Ãµes auxiliares: manipulaÃ§Ã£o de strings, tratamento de erros, gerenciamento de memÃ³ria, etc.
â”‚   â”œâ”€â”€ utils.h           // ProtÃ³tipos das funÃ§Ãµes utilitÃ¡rias
â”‚   â””â”€â”€ wildcard.c        // FunÃ§Ã£o(s) especÃ­fica(s) para expansÃ£o de wildcards (*) (bonus)
â””â”€â”€ libft                 // Pasta contendo a sua prÃ³pria libft
    â”œâ”€â”€ Makefile          // Makefile da libft
    â”œâ”€â”€ *.c               // CÃ³digo fonte da libft
    â””â”€â”€ *.h               // Headers da libft

________________________________________________________________________________________________________

                                                                        ğŸ§­ï¸ğŸ’»ï¸Historico de aÃ§Ãµes na criaÃ§Ã£o do projeto MinishellğŸ§­ï¸ğŸ’»ï¸                                                                  26/02/2025
 âš ï¸main.câš ï¸
ğŸš©ï¸OBS: Deixaremos o Makefile e os arquivos.h "por ultimo".ğŸš©ï¸
Vamos comeÃ§ar criando o arquivo main.c. Nele, teremos a funÃ§Ã£o principal que inicializa o ambiente do shell, configura os signal handlers (deixarei um comentÃ¡rio indicando onde implementar) e entra num loop principal para ler os comandos, chamar o parser e o executor e, por fim, liberar os recursos.
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸InicializaÃ§Ã£o do Shell:
A funÃ§Ã£o init_shell (a ser implementada) deve copiar o ambiente (envp) e preparar as variÃ¡veis necessÃ¡rias para o funcionamento do shell.

2ï¸âƒ£ï¸Signal Handlers:
A funÃ§Ã£o setup_signals Ã© chamada para configurar o tratamento dos sinais (como ctrl-C, ctrl-D e ctrl-\), evitando que o shell saia de forma inesperada.

3ï¸âƒ£ï¸Loop Principal:
Dentro do loop, usamos readline para exibir o prompt e ler o comando do usuÃ¡rio. Se a linha nÃ£o estiver vazia, ela Ã© adicionada ao histÃ³rico com add_history. Em seguida, o comando Ã© passado para o parser (parse_input), que deve montar a estrutura dos comandos, e, se nÃ£o houver erro, o executor (execute_commands) Ã© chamado.

4ï¸âƒ£ï¸LiberaÃ§Ã£o de Recursos:
Ao final de cada iteraÃ§Ã£o, a linha lida e as estruturas temporÃ¡rias sÃ£o liberadas para evitar vazamentos de memÃ³ria. Ao sair do loop (quando o usuÃ¡rio envia um EOF com ctrl-D), o shell Ã© finalizado com free_shell.

Com esse arquivo main.c temos o ponto de entrada do nosso Minishell. Nos prÃ³ximos passos, iremos criar os arquivos dos mÃ³dulos (parser, executor, builtins, utils) e, por fim, os headers e o Makefile


                                                                                                   â€¼ï¸â€¼ï¸PARSERâ€¼ï¸â€¼ï¸  ğŸ³ï¸ğŸš©ï¸ OBS:Ã‰ no Parser que sera implementado o BÃ´nus.ğŸš©ï¸ğŸ³ï¸            

âš ï¸parser.câš ï¸                                                                                                
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸tokenize_line:
Essa funÃ§Ã£o (a ser implementada) deve dividir a linha em tokens, considerando espaÃ§os, aspas, redirecionamentos e pipes.

2ï¸âƒ£ï¸build_commands:
ApÃ³s tokenizar, essa funÃ§Ã£o monta a estrutura de comandos na estrutura do shell (t_shell), para que o executor possa processÃ¡-la.

3ï¸âƒ£ï¸free_tokens:
Libera a memÃ³ria alocada para os tokens, evitando vazamentos.

Essa implementaÃ§Ã£o estÃ¡ simplificada e serve como ponto de partida. Cada funÃ§Ã£o chamada aqui (como tokenize_line, build_commands e free_tokens)

âš ï¸executer.câš ï¸
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸VerificaÃ§Ã£o de Comando:
Se a lista de comandos estiver vazia, retorna imediatamente com sucesso. Se o comando atual for um built-in, ele Ã© executado diretamente sem criar um novo processo.

2ï¸âƒ£ï¸CriaÃ§Ã£o de Processo:
Utilizamos fork() para criar um processo filho. Caso ocorra erro, imprimimos a mensagem de erro e retornamos ERROR.

3ï¸âƒ£ï¸Processo Filho:
No processo filho, chamamos a funÃ§Ã£o setup_redirections para configurar redirecionamentos e pipes (caso implementados). Em seguida, usamos execve() para executar o comando. Se ocorrer algum erro em execve(), a mensagem de erro Ã© exibida e o processo Ã© finalizado.

4ï¸âƒ£ï¸Processo Pai:
O processo pai aguarda o tÃ©rmino do filho com waitpid() e armazena o status de saÃ­da em shell->last_status.

âš ï¸builtins.câš ï¸

Contem as funÃ§Ãµes responsÃ¡veis por identificar e executar os comandos internos (builtins) do shell, como echo, cd, pwd, export, unset, env e exit.
	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸
1ï¸âƒ£ï¸is_builtin:
Essa funÃ§Ã£o recebe o nome do comando e verifica, utilizando a funÃ§Ã£o ft_strcmp da sua libft, se ele corresponde a algum dos builtins. Cada comparaÃ§Ã£o Ã© feita em uma linha separada para garantir clareza e conformidade com a Norm.

2ï¸âƒ£ï¸execute_builtin:
Essa funÃ§Ã£o chama a funÃ§Ã£o especÃ­fica do builtin, passando os argumentos necessÃ¡rios. Cada comando Ã© tratado em uma condiÃ§Ã£o separada. A ideia Ã© que as funÃ§Ãµes como builtin_echo, builtin_cd, etc., sejam implementadas em outros arquivos (ou no prÃ³prio mÃ³dulo) com o cuidado de nÃ£o ultrapassar 25 linhas por funÃ§Ã£o.

âš ï¸utils.câš ï¸
ReunirÃ¡ funÃ§Ãµes auxiliares que poderÃ£o ser utilizadas em todo o projeto. AlÃ©m de funÃ§Ãµes de tratamento de erros e manipulaÃ§Ã£o de strings (quando necessÃ¡rio), vamos incluir aqui tambÃ©m uma funÃ§Ã£o para expandir wildcards, que Ã© Ãºtil para o bÃ´nus.

	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸

1ï¸âƒ£ï¸ft_error:
Essa funÃ§Ã£o recebe uma mensagem e a exibe na saÃ­da de erro padrÃ£o, utilizando uma funÃ§Ã£o da sua libft (como ft_putendl_fd). Ela retorna um valor de erro para facilitar o tratamento nas demais funÃ§Ãµes.

2ï¸âƒ£ï¸expand_wildcards:
Essa funÃ§Ã£o verifica se o padrÃ£o Ã© exatamente "*". Se sim, ela abre o diretÃ³rio atual com opendir, conta os arquivos que nÃ£o comeÃ§am com ponto (ocultos), aloca um array de strings para armazenar os nomes e, em seguida, preenche esse array com os nomes dos arquivos usando ft_strdup (da sua libft). Ao final, retorna o array ou NULL caso ocorra algum erro.

âš ï¸parse_bonus_logic.câš ï¸

	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸

VerificaÃ§Ã£o Inicial:
A funÃ§Ã£o verifica se a lista de tokens Ã© vÃ¡lida. Se estiver vazia, retorna SUCCESS.

1ï¸âƒ£ï¸Tratamento de ParÃªnteses:
Quando encontra um token de abertura de parÃªnteses (TOKEN_PAREN_OPEN), a funÃ§Ã£o chama-se recursivamente para processar a sub-expressÃ£o. Se o token de fechamento (TOKEN_PAREN_CLOSE) nÃ£o for encontrado, retorna um erro.

2ï¸âƒ£ï¸Operadores LÃ³gicos:
Ao encontrar um token de operador lÃ³gico (TOKEN_LOGIC), a implementaÃ§Ã£o deve criar um nÃ³ na Ã¡rvore de comandos para representar o operador, combinando os comandos Ã  esquerda e Ã  direita de acordo com a precedÃªncia.

3ï¸âƒ£ï¸Tokens Comuns:
Para tokens que representam comandos normais, vocÃª pode chamar funÃ§Ãµes jÃ¡ existentes (por exemplo, build_commands) para processÃ¡-los.

Esse esqueleto deve ser adaptado conforme as estruturas de dados como t_token e t_command  e as funÃ§Ãµes auxiliares da sua libft e do projeto.

âš ï¸executer_bonus.câš ï¸

	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸

VerificaÃ§Ã£o Inicial:
Se a Ã¡rvore de comando estiver vazia, a funÃ§Ã£o retorna SUCCESS.

Operadores LÃ³gicos:
Se o nÃ³ atual for do tipo NODE_LOGIC, a funÃ§Ã£o processa recursivamente o lado esquerdo da Ã¡rvore. Em seguida, verifica o operador:

Para &&, se o status do lado esquerdo for diferente de 0 (falha), interrompe e retorna o status.
Para ||, se o status do lado esquerdo for 0 (sucesso), interrompe e retorna o status. ApÃ³s isso, processa o lado direito da Ã¡rvore.
ExpansÃ£o de Wildcards:
Se o comando contÃ©m wildcards (verificado pela funÃ§Ã£o has_wildcard), os argumentos do comando sÃ£o expandidos chamando expand_wildcards.

ExecuÃ§Ã£o do Comando:
Se o comando for um built-in, chama execute_builtin; caso contrÃ¡rio, chama execute_external para criar um processo filho e executar o comando.

Essa implementaÃ§Ã£o Ã© um esqueleto que vocÃª deverÃ¡ adaptar e expandir conforme a sua estrutura de dados e necessidades do projeto.

âš ï¸wildcard.câš ï¸

	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸

expand_wildcards:

Verifica se o padrÃ£o Ã© exatamente "*".
Abre o diretÃ³rio atual com opendir e conta quantos arquivos nÃ£o ocultos existem.
Aloca um array de strings com espaÃ§o para todos os arquivos encontrados, mais um elemento nulo para terminar o array.
Preenche o array com os nomes dos arquivos utilizando ft_strdup (funÃ§Ã£o da sua libft) e, por fim, retorna o array.
has_wildcard:

Percorre a string do comando e retorna 1 se encontrar o caractere '*', ou 0 caso contrÃ¡rio.

----------------------------------------------------------------------------------------------------

																				03/03/25

âš ï¸stubs.câš ï¸

	ğŸ‘¨â€ğŸ«ï¸ExplicaÃ§Ã£o do CÃ³digoğŸ‘¨â€ğŸ«ï¸

arquivo foi criado somente para testar o programa 


 
